// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"
)

type AddAssetToBucketInput struct {
	BucketID string `json:"bucketId"`
	AssetID  string `json:"assetId"`
	OwnerID  string `json:"ownerId"`
}

type AddImageInput struct {
	AssetID     string    `json:"assetId"`
	Type        ImageType `json:"type"`
	FileName    string    `json:"fileName"`
	Bucket      string    `json:"bucket"`
	Key         string    `json:"key"`
	URL         string    `json:"url"`
	ContentType string    `json:"contentType"`
	Size        int       `json:"size"`
}

type AddVideoInput struct {
	AssetID     string      `json:"assetId"`
	Label       string      `json:"label"`
	Format      VideoFormat `json:"format"`
	Bucket      string      `json:"bucket"`
	Key         string      `json:"key"`
	URL         string      `json:"url"`
	ContentType string      `json:"contentType"`
	Size        int         `json:"size"`
}

type Asset struct {
	ID          string       `json:"id"`
	Slug        string       `json:"slug"`
	Title       *string      `json:"title,omitempty"`
	Description *string      `json:"description,omitempty"`
	Type        *string      `json:"type,omitempty"`
	Genre       *string      `json:"genre,omitempty"`
	Genres      []string     `json:"genres"`
	Tags        []string     `json:"tags"`
	CreatedAt   time.Time    `json:"createdAt"`
	UpdatedAt   time.Time    `json:"updatedAt"`
	OwnerID     *string      `json:"ownerId,omitempty"`
	ParentID    *string      `json:"parentId,omitempty"`
	Parent      *Asset       `json:"parent,omitempty"`
	Children    []*Asset     `json:"children"`
	Images      []*Image     `json:"images"`
	Videos      []*Video     `json:"videos"`
	Credits     []*Credit    `json:"credits"`
	PublishRule *PublishRule `json:"publishRule,omitempty"`
	Metadata    *string      `json:"metadata,omitempty"`
	Status      string       `json:"status"`
}

type AssetPage struct {
	Items   []*Asset `json:"items"`
	NextKey *string  `json:"nextKey,omitempty"`
	HasMore bool     `json:"hasMore"`
}

type Bucket struct {
	ID          string    `json:"id"`
	Key         string    `json:"key"`
	Name        string    `json:"name"`
	Description *string   `json:"description,omitempty"`
	Type        string    `json:"type"`
	Status      *string   `json:"status,omitempty"`
	OwnerID     *string   `json:"ownerId,omitempty"`
	Assets      []*Asset  `json:"assets,omitempty"`
	Metadata    *string   `json:"metadata,omitempty"`
	CreatedAt   time.Time `json:"createdAt"`
	UpdatedAt   time.Time `json:"updatedAt"`
}

type BucketInput struct {
	Key         *string `json:"key,omitempty"`
	Name        *string `json:"name,omitempty"`
	Description *string `json:"description,omitempty"`
	Type        *string `json:"type,omitempty"`
	OwnerID     *string `json:"ownerId,omitempty"`
	Metadata    *string `json:"metadata,omitempty"`
	Status      *string `json:"status,omitempty"`
}

type BucketPage struct {
	Items   []*Bucket `json:"items"`
	NextKey *string   `json:"nextKey,omitempty"`
	HasMore bool      `json:"hasMore"`
}

type CreateAssetInput struct {
	Slug        string   `json:"slug"`
	Title       *string  `json:"title,omitempty"`
	Description *string  `json:"description,omitempty"`
	Type        *string  `json:"type,omitempty"`
	Genre       *string  `json:"genre,omitempty"`
	Genres      []string `json:"genres,omitempty"`
	Tags        []string `json:"tags,omitempty"`
	OwnerID     *string  `json:"ownerId,omitempty"`
	ParentID    *string  `json:"parentId,omitempty"`
	Metadata    *string  `json:"metadata,omitempty"`
}

type Credit struct {
	Role     string `json:"role"`
	Name     string `json:"name"`
	PersonID string `json:"personId"`
}

type Image struct {
	ID              string      `json:"id"`
	FileName        string      `json:"fileName"`
	URL             string      `json:"url"`
	Type            ImageType   `json:"type"`
	StorageLocation *S3Object   `json:"storageLocation,omitempty"`
	Width           *int        `json:"width,omitempty"`
	Height          *int        `json:"height,omitempty"`
	Size            *int        `json:"size,omitempty"`
	ContentType     *string     `json:"contentType,omitempty"`
	StreamInfo      *StreamInfo `json:"streamInfo,omitempty"`
	Metadata        []string    `json:"metadata"`
	CreatedAt       time.Time   `json:"createdAt"`
	UpdatedAt       time.Time   `json:"updatedAt"`
}

type Mutation struct {
}

type PublishRule struct {
	PublishAt   *time.Time `json:"publishAt,omitempty"`
	UnpublishAt *time.Time `json:"unpublishAt,omitempty"`
	Regions     []string   `json:"regions"`
	AgeRating   *string    `json:"ageRating,omitempty"`
}

type PublishRuleInput struct {
	PublishAt   *time.Time `json:"publishAt,omitempty"`
	UnpublishAt *time.Time `json:"unpublishAt,omitempty"`
	Regions     []string   `json:"regions,omitempty"`
	AgeRating   *string    `json:"ageRating,omitempty"`
}

type Query struct {
}

type RemoveAssetFromBucketInput struct {
	BucketID string `json:"bucketId"`
	AssetID  string `json:"assetId"`
	OwnerID  string `json:"ownerId"`
}

type S3Object struct {
	Bucket string `json:"bucket"`
	Key    string `json:"key"`
	URL    string `json:"url"`
}

type StreamInfo struct {
	DownloadURL *string `json:"downloadUrl,omitempty"`
	CdnPrefix   *string `json:"cdnPrefix,omitempty"`
	URL         *string `json:"url,omitempty"`
}

type TranscodingInfo struct {
	JobID       *string    `json:"jobId,omitempty"`
	Progress    *float64   `json:"progress,omitempty"`
	OutputURL   *string    `json:"outputUrl,omitempty"`
	Error       *string    `json:"error,omitempty"`
	CompletedAt *time.Time `json:"completedAt,omitempty"`
}

type Video struct {
	ID                 string           `json:"id"`
	Label              string           `json:"label"`
	Type               VideoType        `json:"type"`
	Format             *VideoFormat     `json:"format,omitempty"`
	StorageLocation    *S3Object        `json:"storageLocation"`
	Width              *int             `json:"width,omitempty"`
	Height             *int             `json:"height,omitempty"`
	Duration           *float64         `json:"duration,omitempty"`
	Bitrate            *int             `json:"bitrate,omitempty"`
	Codec              *string          `json:"codec,omitempty"`
	Size               *int             `json:"size,omitempty"`
	ContentType        *string          `json:"contentType,omitempty"`
	StreamInfo         *StreamInfo      `json:"streamInfo,omitempty"`
	Metadata           []string         `json:"metadata"`
	Status             VideoStatus      `json:"status"`
	Thumbnail          *Image           `json:"thumbnail,omitempty"`
	TranscodingInfo    *TranscodingInfo `json:"transcodingInfo,omitempty"`
	CreatedAt          time.Time        `json:"createdAt"`
	UpdatedAt          time.Time        `json:"updatedAt"`
	Quality            VideoQuality     `json:"quality"`
	IsReady            bool             `json:"isReady"`
	IsProcessing       bool             `json:"isProcessing"`
	IsFailed           bool             `json:"isFailed"`
	SegmentCount       *int             `json:"segmentCount,omitempty"`
	VideoCodec         *string          `json:"videoCodec,omitempty"`
	AudioCodec         *string          `json:"audioCodec,omitempty"`
	AvgSegmentDuration *float64         `json:"avgSegmentDuration,omitempty"`
	Segments           []string         `json:"segments,omitempty"`
	FrameRate          *string          `json:"frameRate,omitempty"`
	AudioChannels      *int             `json:"audioChannels,omitempty"`
	AudioSampleRate    *int             `json:"audioSampleRate,omitempty"`
}

type ImageType string

const (
	ImageTypePoster       ImageType = "poster"
	ImageTypeBackdrop     ImageType = "backdrop"
	ImageTypeThumbnail    ImageType = "thumbnail"
	ImageTypeLogo         ImageType = "logo"
	ImageTypeBanner       ImageType = "banner"
	ImageTypeHero         ImageType = "hero"
	ImageTypeScreenshot   ImageType = "screenshot"
	ImageTypeBehindScenes ImageType = "behind_scenes"
	ImageTypeInterview    ImageType = "interview"
)

var AllImageType = []ImageType{
	ImageTypePoster,
	ImageTypeBackdrop,
	ImageTypeThumbnail,
	ImageTypeLogo,
	ImageTypeBanner,
	ImageTypeHero,
	ImageTypeScreenshot,
	ImageTypeBehindScenes,
	ImageTypeInterview,
}

func (e ImageType) IsValid() bool {
	switch e {
	case ImageTypePoster, ImageTypeBackdrop, ImageTypeThumbnail, ImageTypeLogo, ImageTypeBanner, ImageTypeHero, ImageTypeScreenshot, ImageTypeBehindScenes, ImageTypeInterview:
		return true
	}
	return false
}

func (e ImageType) String() string {
	return string(e)
}

func (e *ImageType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ImageType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ImageType", str)
	}
	return nil
}

func (e ImageType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ImageType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ImageType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type VideoFormat string

const (
	VideoFormatRaw  VideoFormat = "raw"
	VideoFormatHls  VideoFormat = "hls"
	VideoFormatDash VideoFormat = "dash"
)

var AllVideoFormat = []VideoFormat{
	VideoFormatRaw,
	VideoFormatHls,
	VideoFormatDash,
}

func (e VideoFormat) IsValid() bool {
	switch e {
	case VideoFormatRaw, VideoFormatHls, VideoFormatDash:
		return true
	}
	return false
}

func (e VideoFormat) String() string {
	return string(e)
}

func (e *VideoFormat) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VideoFormat(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VideoFormat", str)
	}
	return nil
}

func (e VideoFormat) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *VideoFormat) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e VideoFormat) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type VideoQuality string

const (
	VideoQualityLow    VideoQuality = "low"
	VideoQualityMedium VideoQuality = "medium"
	VideoQualityHigh   VideoQuality = "high"
	VideoQualityFourk  VideoQuality = "fourk"
)

var AllVideoQuality = []VideoQuality{
	VideoQualityLow,
	VideoQualityMedium,
	VideoQualityHigh,
	VideoQualityFourk,
}

func (e VideoQuality) IsValid() bool {
	switch e {
	case VideoQualityLow, VideoQualityMedium, VideoQualityHigh, VideoQualityFourk:
		return true
	}
	return false
}

func (e VideoQuality) String() string {
	return string(e)
}

func (e *VideoQuality) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VideoQuality(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VideoQuality", str)
	}
	return nil
}

func (e VideoQuality) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *VideoQuality) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e VideoQuality) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type VideoStatus string

const (
	VideoStatusPending     VideoStatus = "pending"
	VideoStatusAnalyzing   VideoStatus = "analyzing"
	VideoStatusTranscoding VideoStatus = "transcoding"
	VideoStatusReady       VideoStatus = "ready"
	VideoStatusFailed      VideoStatus = "failed"
)

var AllVideoStatus = []VideoStatus{
	VideoStatusPending,
	VideoStatusAnalyzing,
	VideoStatusTranscoding,
	VideoStatusReady,
	VideoStatusFailed,
}

func (e VideoStatus) IsValid() bool {
	switch e {
	case VideoStatusPending, VideoStatusAnalyzing, VideoStatusTranscoding, VideoStatusReady, VideoStatusFailed:
		return true
	}
	return false
}

func (e VideoStatus) String() string {
	return string(e)
}

func (e *VideoStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VideoStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VideoStatus", str)
	}
	return nil
}

func (e VideoStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *VideoStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e VideoStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type VideoType string

const (
	VideoTypeMain      VideoType = "main"
	VideoTypeTrailer   VideoType = "trailer"
	VideoTypeBehind    VideoType = "behind"
	VideoTypeInterview VideoType = "interview"
)

var AllVideoType = []VideoType{
	VideoTypeMain,
	VideoTypeTrailer,
	VideoTypeBehind,
	VideoTypeInterview,
}

func (e VideoType) IsValid() bool {
	switch e {
	case VideoTypeMain, VideoTypeTrailer, VideoTypeBehind, VideoTypeInterview:
		return true
	}
	return false
}

func (e VideoType) String() string {
	return string(e)
}

func (e *VideoType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = VideoType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid VideoType", str)
	}
	return nil
}

func (e VideoType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *VideoType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e VideoType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
